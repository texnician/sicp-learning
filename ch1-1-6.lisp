;; Exercise 1.1.  Below is a sequence of expressions. What is the result printed by
;; the interpreter in response to each expression? Assume that the sequence is to
;; be evaluated in the order in which it is presented.
10

(+ 5 3 4)

(- 9 1)

(/ 6 2)

(setf *a* 3)

(setf *b* (+ *a* 1))

(+ *a* *b* (* *a* *b*))

(eq *a* *b*)

(if (and (> *b* *a*) (< *b* (* *a* *b*)))
    *b*
    *a*)

(cond ((eq *a* 4) 6)
      ((eq *b* 4) (+ 6 7 *a*))
      (t 25))

(+ 2 (if (> *b* *a*)
         *b* *a*))

(* (cond ((> *a* *b*) *a*)
         ((> *b* *a*) *b*)
         (t -1))
   (+ *a* 1))

;; Exercise 1.2.  Translate the following expression into prefix form
(/ (+ 5 4 (- 2 (- 3 (+ 6 4/5))))
   (* 3 (- 6 2) (- 2 7)))

;; Exercise 1.3.  Define a procedure that takes three numbers as arguments and
;; returns the sum of the squares of the two larger numbers.
(defun square (x)
  (* x x))

(defun max1 (x y)
  (if (> x y)
      x
      y))

(defun min1 (x y)
  (if (< x y)
      x
      y))

(defun sum-of-square (x y)
  (+ (square x) (square y)))

(defun sum-of-two-larger-square (x y z)
  (cond ((< x (min1 y z)) (sum-of-square y z))
        (t (sum-of-square x (max1 y z)))))

(sum-of-two-larger-square 1 2 3)
(sum-of-two-larger-square 1 3 2)
(sum-of-two-larger-square 2 1 3)
(sum-of-two-larger-square 2 3 1)
(sum-of-two-larger-square 3 1 2)
(sum-of-two-larger-square 3 2 1)

;; Exercise 1.4 Exercise 1.4.  Observe that our model of evaluation allows for
;; combinations whose operators are compound expressions. Use this observation
;; to describe the behavior of the following procedure:

;; (define (a-plus-abs-b a b)
;;   ((if (> b 0) + -) a b))
(defun a-plus-abs-b (a b)
  (funcall (if (> b 0) #'+ #'-) a b))

(a-plus-abs-b 1 2)
(a-plus-abs-b 1 -2)


;; Exercise 1.7.  The good-enough? test used in computing square roots will not
;; be very effective for finding the square roots of very small numbers. Also,
;; in real computers, arithmetic operations are almost always performed with
;; limited precision. This makes our test inadequate for very large
;; numbers. Explain these statements, with examples showing how the test fails
;; for small and large numbers. An alternative strategy for implementing
;; good-enough? is to watch how guess changes from one iteration to the next and
;; to stop when the change is a very small fraction of the guess. Design a
;; square-root procedure that uses this kind of end test. Does this work better
;; for small and large numbers?
(defun sqrt-iter (guess x)
  (format t "~f " guess)
  (if (good-enoughp guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(defun improve (guess x)
  (average guess (/ x guess)))

(defun average (x y)
  (/ (+ x y) 2))

(defun good-enoughp (guess x)
  (< (abs (- (square guess) x)) 0.001))

(defun sqrt1 (x)
  (sqrt-iter 1.0 x))

(defun good-enough2p (diff)
  (< (abs diff) 0.001))


(defun sqrt-iter2 (guess x)
  (format t "~f " guess)
  (if (good-enough2p (- (improve guess x) guess))
      guess
      (sqrt-iter2 (improve guess x)
                  x)))

(defun sqrt2 (x)
  (sqrt-iter2 1.0 x))

;; Exercise 1.9.  Each of the following two procedures defines a method for
;; adding two positive integers in terms of the procedures inc, which increments
;; its argument by 1, and dec, which decrements its argument by 1.

;; (define (+ a b)
;;   (if (= a 0)
;;       b
;;       (inc (+ (dec a) b))))

;; (define (+ a b)
;;   (if (= a 0)
;;       b
;;       (+ (dec a) (inc b))))

;; Using the substitution model, illustrate the process generated by each
;; procedure in evaluating (+ 4 5). Are these processes iterative or recursive?
(defun add1 (a b)
  (if (eq a 0)
      b
      (1+ (add1 (1- a) b))))

(add1 4 5)
(1+ (add1 3 5))
(1+ (1+ (add1 2 5)))
(1+ (1+ (1+ (add1 1 5))))
(1+ (1+ (1+ (1+ (add1 0 5)))))
(1+ (1+ (1+ (1+ 5))))
(1+ (1+ (1+ 6)))
(1+ (1+ 7))
(1+ 8)
9

(defun add2 (a b)
  (if (eq a 0)
      b
      (add2 (1- a) (1+ b))))
(add2 4 5)
(add2 3 6)
(add2 2 7)
(add2 1 8)
(add2 0 9)
9

;; Exercise 1.10.  The following procedure computes a mathematical function
;; called Ackermann's function.

;; (define (A x y)
;;   (cond ((= y 0) 0)
;;         ((= x 0) (* 2 y))
;;         ((= y 1) 2)
;;         (else (A (- x 1)
;;                  (A x (- y 1))))))

;; What are the values of the following expressions?

;; (A 1 10)

;; (A 2 4)

;; (A 3 3)

;; Consider the following procedures, where A is the procedure defined above:

;; (define (f n) (A 0 n))

;; (define (g n) (A 1 n))

;; (define (h n) (A 2 n))

;; (define (k n) (* 5 n n))

;; Give concise mathematical definitions for the functions computed by the
;; procedures f, g, and h for positive integer values of n. For example, (k n)
;; computes 5n2.

(defun A (x y)
  (cond ((eq y 0) 0)
        ((eq x 0) (* 2 y))
        ((eq y 1) 2)
        (t (A (1- x)
              (A x (1- y))))))

;; (A 1 10)
;; (A 0 (A 1 9))
;; (A 0 (A 0 (A 1 8)))
;; (A 0 (A 0 (A 0 (A 1 7))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
;; (A 0 (A 0 (A 0 (A 0 64))))
;; (A 0 (A 0 (A 0 128)))
;; (A 0 (A 0 256))
;; (A 0 512)
;; 1024

;; (A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (A 0 (A 1 1))))
;; (A 1 (A 1 (A 0 2)))
;; (A 1 (A 1 4))
;; (A 1 (A 0 (A 1 3)))
;; (A 1 (A 0 (A 0 (A 1 2))))
;; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 1 (A 0 (A 0 (A 0 2))))
;; (A 1 (A 0 (A 0 4)))
;; (A 1 (A 0 8))
;; (A 1 16)
;; (A 0 (A 1 15))
;; (A 0 (A 0 (A 1 14)))
;; (A 0 (A 0 (A 0 (A 1 13))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
;; (A 0 (A 0 (A 0 (A 0 4096))))
;; (A 0 (A 0 (A 0 8192)))
;; (A 0 (A 0 16384))
;; (A 0 32768)
;; 65536

;; (A 3 3)
;; (A 2 (A 3 2))
;; (A 2 (A 2 (A 3 1)))
;; (A 2 (A 2 2))
;; (A 2 (A 1 (A 2 1)))
;; (A 2 (A 1 2))
;; (A 2 (A 0 (A 1 1)))
;; (A 2 (A 0 2))
;; (A 2 4)

;; 2n
(defun A-f (n)
  (A 0 n))                              

;; 2^n
(defun A-g (n)
  (A 1 n))

;; 2_1^2_2^2_3..2_n
(defun A-h (n)
  (A 2 n))

;; Exercise 1.11.  A function f is defined by the rule that f(n) = n if n<3 and
;; f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n> 3. Write a procedure that
;; computes f by means of a recursive process. Write a procedure that computes f
;; by means of an iterative process.
(defun fb3 (n)
  (if (< n 3)
      n
      (+ (fb3 (- n 1))
         (* 2 (fb3 (- n 2)))
         (* 3 (fb3 (- n 3))))))

(defun fb3-2 (n)
  (fb3-iter 0 1 2 n))

(defun fb3-iter (a b c count)
  (if (eq count 0)
       a
       (fb3-iter b c (+ c (* 2 b) (* 3 a)) (1- count))))

;; Exercise 1.12.  The following pattern of numbers is called Pascal's triangle.

;; The numbers at the edge of the triangle are all 1, and each number inside the
;; triangle is the sum of the two numbers above it.35 Write a procedure that
;; computes elements of Pascal's triangle by means of a recursive process.
(defun pascal-triangle (n k)
  (cond ((eq k 1) 1)
        ((eq k n) 1)
        (t (+ (pascal-triangle (1- n) (1- k))
              (pascal-triangle (1- n) k)))))

;; Exercise 1.16.  Design a procedure that evolves an iterative exponentiation
;; process that uses successive squaring and uses a logarithmic number of steps,
;; as does fast-expt. (Hint: Using the observation that (bn/2)2 = (b2)n/2, keep,
;; along with the exponent n and the base b, an additional state variable a, and
;; define the state transformation in such a way that the product a bn is
;; unchanged from state to state. At the beginning of the process a is taken to
;; be 1, and the answer is given by the value of a at the end of the process. In
;; general, the technique of defining an invariant quantity that remains
;; unchanged from state to state is a powerful way to think about the design of
;; iterative algorithms.)
(defun expr-fast (b n)
  (expr-fast-iter 1 b n))

(defun expr-fast-iter (a b n)
  (if (eq n 0)
      a
      (let ((acc (if (evenp n)
                     a
                     (* a b)))
            (h (if (evenp n)
                   (/ n 2)
                   (/ (1- n) 2))))
        (expr-fast-iter acc (square b) h))))

;; Exercise 1.17.  The exponentiation algorithms in this section are based on
;; performing exponentiation by means of repeated multiplication. In a similar
;; way, one can perform integer multiplication by means of repeated
;; addition. The following multiplication procedure (in which it is assumed that
;; our language can only add, not multiply) is analogous to the expt procedure:

;; (define (* a b)
;;   (if (= b 0)
;;       0
;;       (+ a (* a (- b 1)))))

;; This algorithm takes a number of steps that is linear in b. Now suppose we
;; include, together with addition, operations double, which doubles an integer,
;; and halve, which divides an (even) integer by 2. Using these, design a
;; multiplication procedure analogous to fast-expt that uses a logarithmic
;; number of steps.
(defun multi (a b)
  (if (eq 0 b)
      0
      (+ a (multi a (1- b)))))

(defun double (x)
  (+ x x))

(defun halve (x)
  (/ x 2))

(defun fast-multi (a b)
    (cond ((eq 0 b) 0)
          ((evenp b) (double (fast-multi a (halve b))))
          (t (+ a (fast-multi a (1- b))))))

;; Exercise 1.18.  Using the results of exercises 1.16 and 1.17, devise a
;; procedure that generates an iterative process for multiplying two integers in
;; terms of adding, doubling, and halving and uses a logarithmic number of
;; steps.40
(defun fast-multi-iter (a b)
  (labels ((multi-iter (acc x y)
             (cond ((eq 0 y) acc)
                   ((evenp y) (multi-iter acc (double x) (halve y)))
                   (t (multi-iter (+ acc x) x (1- y))))))
    (funcall #'multi-iter 0 a b)))


;; Exercise 1.19.  There is a clever algorithm for computing the Fibonacci
;; numbers in a logarithmic number of steps. Recall the transformation of the
;; state variables a and b in the fib-iter process of section 1.2.2: a a + b and
;; b a. Call this transformation T, and observe that applying T over and over
;; again n times, starting with 1 and 0, produces the pair Fib(n + 1) and
;; Fib(n). In other words, the Fibonacci numbers are produced by applying Tn,
;; the nth power of the transformation T, starting with the pair (1,0). Now
;; consider T to be the special case of p = 0 and q = 1 in a family of
;; transformations Tpq, where Tpq transforms the pair (a,b) according to a bq +
;; aq + ap and b bp + aq. Show that if we apply such a transformation Tpq twice,
;; the effect is the same as using a single transformation Tp'q' of the same
;; form, and compute p' and q' in terms of p and q. This gives us an explicit
;; way to square these transformations, and thus we can compute Tn using
;; successive squaring, as in the fast-expt procedure. Put this all together to
;; complete the following procedure, which runs in a logarithmic number of
;; steps:41

;; (define (fib n)
;;   (fib-iter 1 0 0 1 n))
;; (define (fib-iter a b p q count)
;;   (cond ((= count 0) b)
;;         ((even? count)
;;          (fib-iter a
;;                    b
;;                    <??>      ; compute p'
;;                    <??>      ; compute q'
;;                    (/ count 2)))
;;         (else (fib-iter (+ (* b q) (* a q) (* a p))
;;                         (+ (* b p) (* a q))
;;                         p
;;                         q
;;                         (- count 1)))))
(defun fast-fib (n)
  (fast-fib-iter 1 0 0 1 n))

(defun fast-fib-iter (a b p q count)
  (cond ((= count 0) b)
        ((evenp count)
         (fast-fib-iter a
                        b
                        ;; p' = p^2 + q^2
                        (+ (square p) (square q))
                        ;; q' = q^2 + 2pq 
                        (+ (square q) (* 2 p q))
                        (/ count 2)))
        (t (fast-fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (1- count)))))

;; Exercise 1.20.  The process that a procedure generates is of course dependent
;; on the rules used by the interpreter. As an example, consider the iterative
;; gcd procedure given above. Suppose we were to interpret this procedure using
;; normal-order evaluation, as discussed in section 1.1.5. (The
;; normal-order-evaluation rule for if is described in exercise 1.5.) Using the
;; substitution method (for normal order), illustrate the process generated in
;; evaluating (gcd 206 40) and indicate the remainder operations that are
;; actually performed. How many remainder operations are actually performed in
;; the normal-order evaluation of (gcd 206 40)? In the applicative-order
;; evaluation?
(defun gcd1 (a b)
  (if (eq 0 b)
      a
      (gcd1 b (mod a b))))

(gcd1 206 40)
;; Normal-order
(gcd1 40 (mod 206 40))                  ; 0 + 1
(gcd1 (mod 206 40) (mod 40 (mod 206 40))) ; 1 + 1 = 2
(gcd1 (mod 40 (mod 206 40)) (mod (mod 206 40) (mod 40 (mod 206 40)))) ; 2 + 1 + 1 = 4
(gcd1 (mod (mod 206 40) (mod 40 (mod 206 40))) (mod (mod 40 (mod 206 40)) (mod (mod 206 40) (mod 40 (mod 206 40))))) ; 4 + 2 + 1 = 7
(mod (mod 206 40) (mod 40 (mod 206 40))) ; 4
2
;; (+ 1 2 4 7 4) => 18 times

;; Applicative-order
(gcd1 40 (mod 206 40))
(gcd1 40 6)
(gcd1 6 (mod 40 6))
(gcd1 6 4)
(gcd1 4 (mod 6 4))
(gcd1 4 2)
(gcd1 2 (mod 4 2))
(gcd1 2 0)
2

;; 4 times.

;; Exercise 1.21.  Use the smallest-divisor procedure to find the smallest
;; divisor of each of the following numbers: 199, 1999, 19999.
(defun smallest-divisor (n)
  (find-divisor n 2))

(defun find-divisor (n test-divisor)
  (cond ((devidesp n test-divisor) test-divisor)
        ((> (square test-divisor) n) n)
        (t (find-divisor n (1+ test-divisor)))))

(defun devidesp (n d)
  (eq 0 (mod n d)))

;; (smallest-divisor 199)
;; (smallest-divisor 1999)
;; (smallest-divisor 19999)

;; Exercise 1.22.  Most Lisp implementations include a primitive called runtime
;; that returns an integer that specifies the amount of time the system has been
;; running (measured, for example, in microseconds). The following
;; timed-prime-test procedure, when called with an integer n, prints n and
;; checks to see if n is prime. If n is prime, the procedure prints three
;; asterisks followed by the amount of time used in performing the test.

;; (define (timed-prime-test n)
;;   (newline)
;;   (display n)
;;   (start-prime-test n (runtime)))
;; (define (start-prime-test n start-time)
;;   (if (prime? n)
;;       (report-prime (- (runtime) start-time))))
;; (define (report-prime elapsed-time)
;;   (display " *** ")
;;   (display elapsed-time))

;; Using this procedure, write a procedure search-for-primes that checks the
;; primality of consecutive odd integers in a specified range. Use your
;; procedure to find the three smallest primes larger than 1000; larger than
;; 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to
;; test each prime. Since the testing algorithm has order of growth of (n), you
;; should expect that testing for primes around 10,000 should take about 10
;; times as long as testing for primes around 1000. Do your timing data bear
;; this out? How well do the data for 100,000 and 1,000,000 support the n
;; prediction? Is your result compatible with the notion that programs on your
;; machine run in time proportional to the number of steps required for the
;; computation?
(defun primep (n)
  (eq (smallest-divisor n) n))

(defun timed-prime-test (n)
  (format t "~d" n)
  (start-prime-test n (get-internal-run-time)))

(defun start-prime-test (n start-time)
  (if (primep n)
      (report-prime (- (get-internal-run-time) start-time))))

(defun report-prime (elapsed-time)
  (format t " *** ~d" elapsed-time))

;; (timed-prime-test 1009)
;; (timed-prime-test 1013)
;; (timed-prime-test 1019)
;; (timed-prime-test 10007)
;; (timed-prime-test 10009)
;; (timed-prime-test 10037)
;; (timed-prime-test 100003)
;; (timed-prime-test 100019)
;; (timed-prime-test 100043)
;; (timed-prime-test 1000003)
;; (timed-prime-test 1000033)
;; (timed-prime-test 1000037)
;; (timed-prime-test 10000019)
;; (timed-prime-test 10000079)
;; (timed-prime-test 10000103)

;; Exercise 1.23.  The smallest-divisor procedure shown at the start of this
;; section does lots of needless testing: After it checks to see if the number
;; is divisible by 2 there is no point in checking to see if it is divisible by
;; any larger even numbers. This suggests that the values used for test-divisor
;; should not be 2, 3, 4, 5, 6, ..., but rather 2, 3, 5, 7, 9, .... To implement
;; this change, define a procedure next that returns 3 if its input is equal to
;; 2 and otherwise returns its input plus 2. Modify the smallest-divisor
;; procedure to use (next test-divisor) instead of (+ test-divisor 1). With
;; timed-prime-test incorporating this modified version of smallest-divisor, run
;; the test for each of the 12 primes found in exercise 1.22. Since this
;; modification halves the number of test steps, you should expect it to run
;; about twice as fast. Is this expectation confirmed? If not, what is the
;; observed ratio of the speeds of the two algorithms, and how do you explain
;; the fact that it is different from 2?
